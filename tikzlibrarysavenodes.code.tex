\RequirePackage{expl3, l3keys2e, xparse}

\ExplSyntaxOn

% We save our information in a ``property list'', which is L3's
% version of an associative array or dictionary.  They keys will give
% the ability to store several groups of nodes and restore them at
% will.
\prop_new:N \g__sn_prop
% We'll need a token list for constructing the saved data.
\tl_new:N \l__sn_tmpa_tl
% And one for constructing the save file command
\tl_new:N \l__sn_tmpb_tl
% Testing a minus sign for shifting a node
\tl_new:N \l__sn_minus_tl
\tl_set:Nn \l__sn_minus_tl {-}

% Dimensions for shifting
\dim_new:N \l__sn_x_dim
\dim_new:N \l__sn_y_dim
\dim_new:N \l__sn_xa_dim
\dim_new:N \l__sn_ya_dim
\tl_new:N \l__sn_centre_tl

\tl_new:N \l__sn_transformation_tl
\tl_set:Nn \l__sn_transformation_tl {{1}{0}{0}{1}{0pt}{0pt}}

% Set up a stream for saving the nodes data to a file
\iow_new:N \g__sn_stream
\iow_open:Nn \g__sn_stream {\jobname.nodes}

\AtEndDocument
{
  \ExplSyntaxOn
  \iow_close:N \g__sn_stream
  \ExplSyntaxOff
}

% This is the command that actually does the work.  It constructs a
% token list which contains the code that will restore the node data
% when invoked.  The two arguments are the name of this group (for
% reference later) and a comma separated list of the node names to be
% saved.
\cs_new_nopar:Npn \save_nodes:nn #1#2
{
  % Clear our token lists
  \tl_clear:N \l__sn_tmpa_tl
  % Set the centre of the picture
  \tikz_scan_point:NNn \l__sn_x_dim \l__sn_y_dim {(current~ bounding~ box.center)}
  \dim_set:Nn \l__sn_x_dim {-\l__sn_x_dim}
  \dim_set:Nn \l__sn_y_dim {-\l__sn_y_dim}
  \tl_set:Nx \l__sn_centre_tl {{1}{0}{0}{1}{\dim_use:N \l__sn_x_dim}{\dim_use:N \l__sn_y_dim}}
  
  % Iterate over the list of node names
  \clist_map_inline:nn {#2}
  {
    % Test to see if the node has been defined
    \tl_if_exist:cT {pgf@sh@ns@##1}
    {
      % The node information is stored in a series of macros of the form
      % \pgf@sh@XX@nodename where XX is one of the following.
      \clist_map_inline:nn {ns,np,ma,pi}
      {
        % Our token list will look like:
        %
        % \tl_set:cn {pgf@sh@XX@nodename} {<current contents of that macro>}
        %
        % This will restore \pgf@sh@XX@nodename to its current value
        % when this list is invoked.
        %
        % This part puts the \tl_set:cn {pgf@sh@XX@nodename} in place
        \tl_put_right:Nn \l__sn_tmpa_tl
        {
          \tl_gset:cn {pgf@sh@####1@ \tikz_set_node_name:n{##1} }
        }
        % Now we put the current contents in place.  We're doing this in
        % an expansive context to get at the contents.  The \exp_not:v
        % part takes the current value of \pgf@sh@XX@nodename and puts
        % it in place, preventing further expansion.
        \tl_if_exist:cTF {pgf@sh@####1@##1}
        {
          \tl_put_right:Nx \l__sn_tmpa_tl {{\exp_not:v {pgf@sh@####1@ \tikz_set_node_name:n {##1}}}}
        }
        {
          \tl_put_right:Nx \l__sn_tmpa_tl {{}}
        }
      }
      \tl_put_right:Nn \l__sn_tmpa_tl
      {
        \tl_gset:cn {pgf@sh@nt@ \tikz_set_node_name:n{##1} }
      }
      \compose_transformations:NVv \l__sn_tmpb_tl \l__sn_centre_tl {pgf@sh@nt@##1}
      \tl_put_right:Nx \l__sn_tmpa_tl {{\exp_not:V \l__sn_tmpb_tl}}
      \tl_put_right:Nn \l__sn_tmpa_tl {\transform_node:Nn \l__sn_transformation_tl {\tikz_set_node_name:n{##1}} }
    }
  }
  % Once we've assembled our token list, we store it in the property
  % list using the key we were given.
  \prop_gput:NnV \g__sn_prop {#1} \l__sn_tmpa_tl
}

\cs_new_nopar:Npn \restore_nodes:n #1
{
  % Restoring nodes is simple: look in the property list for the key
  % and if it exists, invoke the macro stored there.
  \prop_get:NnNT \g__sn_prop {#1} \l__sn_tmpa_tl
  {
    \tl_use:N \l__sn_tmpa_tl
  }
}

\cs_new_nopar:Npn \save_nodes_to_file:n #1
{
  % Save the token list to the aux file so that on reading the aux
  % file, we restore it to the prop
  \prop_get:NnNT \g__sn_prop {#1} \l__sn_tmpa_tl
  {
    \tl_clear:N \l__sn_tmpb_tl
    \tl_set:Nn \l__sn_tmpb_tl
    {
      \prop_gput:Nnn \g__sn_prop {#1}
    }
    \tl_put_right:Nx \l__sn_tmpb_tl {{\exp_not:V \l__sn_tmpa_tl}}
    \iow_now:Nx \g__sn_stream
    {
      \iow_newline:
      \exp_not:V \l__sn_tmpb_tl
      \iow_newline:
    }
  }
}

% These two are wrappers around our internal commands.
%
% The first argument is the label for our group of nodes (so that we
% can refer to them later) and the second argument is a comma
% separated list of nodes to save.
\DeclareDocumentCommand \SaveNodes {m m}
{
  \save_nodes:nn {#1}{#2}
}

% The argument to this is the label for our group of nodes to restore.
\DeclareDocumentCommand \RestoreNodes {O{} O{} m}
{
  \scope
  \tikzset{#1}
  \tikzset{#2}
  \restore_nodes:n {#3}
  \endscope
}

\makeatletter
\DeclareDocumentCommand \RestoreAfterNode {m}
{
  \pgfkeysalso{append~ after~ command={\pgfextra{\RestoreNodes[transform~ nodes~ using=\tikz@last@fig@name]#1}}}
}
\makeatother

\DeclareDocumentCommand \LoadNodesFrom {m}
{
  \file_if_exist:nT {#1.nodes}
  {
    \ExplSyntaxOn
    \file_input:n {#1.nodes}
    \ExplSyntaxOff
  }
}

\DeclareDocumentCommand \BakeBoundingBoxAs {m}
{
  \tl_set:cn {pgf@sh@ns@#1}{rectangle}
  \tl_set:cx {pgf@sh@np@#1}{\def \exp_not:N \northeast {\exp_not:N \pgfqpoint{ \dim_use:N \pgf@picmaxx} {\dim_use:N \pgf@picmaxy}} \def \exp_not:N \southwest {\exp_not:N \pgfqpoint {\dim_use:N \pgf@picminx} {\dim_use:N \pgf@picminy}}}
  \tl_set:cn {pgf@sh@ma@#1}{}
  \tl_set:cn {pgf@sh@nt@#1}{{1}{0}{0}{1}{0pt}{0pt}}
  \tl_set:cx {pgf@sh@pi@#1}{\tl_use:N \pgfpictureid}
}

\makeatletter
\cs_set_eq:NN \tikz_set_node_name:n \tikz@pp@name

\cs_new_nopar:Npn \tikz_scan_point:n #1
{
  \tikz@scan@one@point\pgfutil@firstofone#1\relax
}

\cs_new_nopar:Npn \tikz_scan_point:NNn #1#2#3
{
  \tikz@scan@one@point\pgfutil@firstofone#3\relax
  \dim_set_eq:NN #1 \pgf@x
  \dim_set_eq:NN #2 \pgf@y
}

\makeatother

\cs_generate_variant:Nn \tikz_scan_point:n {V}
\cs_generate_variant:Nn \tikz_scan_point:NNn {NNV}

\cs_new_nopar:Npn \shift_node:nn #1#2
{
  \tl_set:Nx \l__sn_tmpa_tl {\tl_head:N {#2}}
  
  \tl_if_eq:NNTF \l__sn_tmpa_tl \l__sn_minus_tl {
    \tl_set:Nx \l__sn_tmpb_tl {\tl_tail:n {#2}}
  }
  {
    \tl_set:Nn \l__sn_tmpb_tl {#2}
  }
  
  \tikz_scan_point:NNV \l__sn_x_dim \l__sn_y_dim \l__sn_tmpb_tl

  \tl_if_eq:NNT \l__sn_tmpa_tl \l__sn_minus_tl {
    \dim_set:Nn \l__sn_x_dim {- \l__sn_x_dim}
    \dim_set:Nn \l__sn_y_dim {- \l__sn_y_dim}
  }

  \tl_set:Nx \l__sn_tmpa_tl
  {
    {1}{0}{0}{1}{\dim_use:N \l__sn_x_dim}{\dim_use:N \l__sn_y_dim}
  }
  
  \compose_transformations:cVv {pgf@sh@nt@#1} \l__sn_tmpa_tl {pgf@sh@nt@#1}
}

% Compose PGF transformations #2 * #3, storing the result in #1

% I think the PGF Manual might be incorrect.  It implies that the
% matrix is stored row-major, but experimentation implies column-major.
%
% That is, {a}{b}{c}{d}{s}{t} is:
%
% [ a c ]
% [ b d ]

\cs_new_nopar:Npn \compose_transformations:Nnn #1#2#3
{
  \tl_gset:Nx #1
  {
    {\fp_eval:n {
        \tl_item:nn {#2} {1}
        * \tl_item:nn {#3} {1}
        +
        \tl_item:nn {#2} {3}
        * \tl_item:nn {#3} {2}
      }
    }
    {\fp_eval:n {
        \tl_item:nn {#2} {2}
        * \tl_item:nn {#3} {1}
        +
        \tl_item:nn {#2} {4}
        * \tl_item:nn {#3} {2}
      }
    }
    {\fp_eval:n {
        \tl_item:nn {#2} {1}
        * \tl_item:nn {#3} {3}
        +
        \tl_item:nn {#2} {3}
        * \tl_item:nn {#3} {4}
      }
    }
    {\fp_eval:n {
        \tl_item:nn {#2} {2}
        * \tl_item:nn {#3} {3}
        +
        \tl_item:nn {#2} {4}
        * \tl_item:nn {#3} {4}
      }
    }
    {\fp_to_dim:n {
        \tl_item:nn {#2} {1}
        * \tl_item:nn {#3} {5}
        +
        \tl_item:nn {#2} {3}
        * \tl_item:nn {#3} {6}
        +
        \tl_item:nn {#2} {5}
      }
    }
    {\fp_to_dim:n {
        \tl_item:nn {#2} {2}
        * \tl_item:nn {#3} {5}
        +
        \tl_item:nn {#2} {4}
        * \tl_item:nn {#3} {6}
        +
        \tl_item:nn {#2} {6}
      }
    }
  }
}

\cs_generate_variant:Nn \compose_transformations:Nnn {cVv,NVv,NVn,NvV,NnV}

\cs_new_nopar:Npn \transform_node:Nn #1#2
{
  \compose_transformations:cVv {pgf@sh@nt@#2} #1 {pgf@sh@nt@#2}
}

\DeclareDocumentCommand \ShiftNode {m m}
{
  \shift_node:nn {#1}{#2}
}

\tikzset{
  transform~ nodes~ using/.code={
    \tl_set_eq:Nc \l__sn_transformation_tl {pgf@sh@nt@#1}
    \tikz_scan_point:NNn \l__sn_x_dim \l__sn_y_dim {(#1.center)}
    
    \dim_set:Nn \l__sn_x_dim {\l__sn_x_dim - \tl_item:cn {pgf@sh@nt@#1}{5}}
    \dim_set:Nn \l__sn_y_dim {\l__sn_y_dim - \tl_item:cn {pgf@sh@nt@#1}{6}}
    
    \compose_transformations:NnV  \l__sn_transformation_tl {{1}{0}{0}{1}{\dim_use:N \l__sn_x_dim}{\dim_use:N \l__sn_y_dim}} \l__sn_transformation_tl

    %% \tl_set:Nx \l__sn_transformation_tl
    %% {
    %%   {\tl_item:cn {pgf@sh@nt@#1} {1}}
    %%   {\tl_item:cn {pgf@sh@nt@#1} {2}}
    %%   {\tl_item:cn {pgf@sh@nt@#1} {3}}
    %%   {\tl_item:cn {pgf@sh@nt@#1} {4}}
    %%   {0pt}
    %%   {0pt}
    %% }
    
  }
}

\DeclareDocumentCommand \SaveNodesToFile {m m}
{
  \save_nodes:nn {#1}{#2}
  \save_nodes_to_file:n {#1}
}

\ExplSyntaxOff

\makeatletter
\tikzset{
  restore nodes from/.code={
    \tikz@fig@mustbenamed
    \RestoreAfterNode{#1}
  },
  save nodes/.style 2 args={
    execute at end picture={\SaveNodesToFile{#1}{#2}}
  },
}
\makeatother
